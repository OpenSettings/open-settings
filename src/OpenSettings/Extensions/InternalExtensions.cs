using Microsoft.EntityFrameworkCore;
using Ogu.Compressions.Abstractions;
using Ogu.Response.Json;
using OpenSettings.Models;
using StackExchange.Redis;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Net.Http.Headers;
using System.Text;
using System.Text.Json;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using ClientInfo = OpenSettings.Models.ClientInfo;

namespace OpenSettings.Extensions
{
    internal static class InternalExtensions
    {
#if NETSTANDARD2_0
        /// <summary>
        /// Tries to get the value associated with the specified key in the dictionary.
        /// </summary>
        /// <typeparam name="TKey"></typeparam>
        /// <typeparam name="TValue"></typeparam>
        /// <param name="dictionary">A dictionary with keys of type TKey and values of type TValue.</param>
        /// <param name="key">The key of the value to get.</param>
        /// <param name="defaultValue"></param>
        /// <returns>
        /// A TValue instance. When the method is successful, the returned object is the
        /// value associated with the specified key. When the method fails, it returns the
        /// default value for TValue.
        /// </returns>
        /// <exception cref="ArgumentNullException">dictionary is null.</exception>
        public static TValue GetValueOrDefault<TKey, TValue>(this IReadOnlyDictionary<TKey, TValue> dictionary, TKey key, TValue defaultValue)
        {
            return dictionary.TryGetValue(key, out var value) ? value : defaultValue;
        }
#endif
        internal static Task<T[]> ToPaginatedArrayAsync<T>(this IQueryable<T> entities, int pageIndex, int pageSize,
            CancellationToken cancellationToken)
        {
            return entities.Skip((pageIndex - 1) * pageSize).Take(pageSize).ToArrayAsync(cancellationToken);
        }

        internal static AuthenticationHeaderValue CreateBasicAuthenticationHeaderValue(this ClientInfo clientInfo)
        {
            return new AuthenticationHeaderValue(Constants.BasicSchemeName, Convert.ToBase64String(Encoding.UTF8.GetBytes($"{clientInfo.Id}:{clientInfo.Secret}")));
        }

        internal static async Task<string> DecompressToUtf8StringAsync(this ICompressionFactory compressionFactory, byte[] data, CompressionType compressionType, CancellationToken cancellationToken = default)
        {
            return Encoding.UTF8.GetString(await compressionFactory.DecompressAsync(compressionType, data, cancellationToken));
        }

        internal static RedisMessage ToRedisMessage(this RedisValue redisValue)
        {
            return JsonSerializer.Deserialize<RedisMessage>(redisValue.ToString());
        }

        /// <summary>
        /// Converts the given string into a URL-friendly slug by trimming, 
        /// converting to lowercase, and replacing spaces or special characters with hyphens.
        /// </summary>
        /// <param name="value">The input string to convert.</param>
        /// <returns>A slug version of the input string.</returns>
        public static string ToSlug(this string value)
        {
            if (string.IsNullOrEmpty(value))
            {
                return string.Empty;
            }

            value = PascalCaseRegex.Replace(value, Constants.SlugReplacement);

            value = value
                .ToLowerInvariant()
                .Replace(Constants.Space, Constants.Hyphen);

            value = InvalidCharactersRegex.Replace(value, Constants.Hyphen);

            value = MultipleDashesRegex.Replace(value, Constants.Hyphen);

            value = value.Trim(Constants.HyphenChar);

            return value;
        }

        private static readonly Regex PascalCaseRegex = new Regex("([a-z])([A-Z])", RegexOptions.Compiled);

        private static readonly Regex InvalidCharactersRegex = new Regex(@"[^a-z0-9\-_]", RegexOptions.Compiled);

        private static readonly Regex MultipleDashesRegex = new Regex("-{2,}", RegexOptions.Compiled);

        /// <summary>
        /// Converts the given <see cref="DateTime"/> to a byte array representing the row version.
        /// The byte array is generated by converting the <see cref="DateTime.Ticks"/> property to a byte array.
        /// </summary>
        /// <param name="dateTime">The <see cref="DateTime"/> to convert to a row version.</param>
        /// <returns>A byte array representing the row version based on the <see cref="DateTime.Ticks"/>.</returns>
        public static byte[] ToRowVersion(this DateTime dateTime)
        {
            return BitConverter.GetBytes(dateTime.Ticks);
        }

        public static async Task<IJsonResponse<TData>> ToJsonResponseAsync<TData>(this DbUpdateConcurrencyException exception, CancellationToken cancellationToken = default)
        {
            var concurrencyConflict = await GetConcurrencyConflictAsync(exception, cancellationToken);

            var jsonResponse = HttpStatusCode.Conflict.ToFailureJsonResponse<TData>("Concurrency Conflict", "The data has been modified or row version didn't match.");

            jsonResponse.Extras["Conflicts"] = concurrencyConflict;

            return jsonResponse;
        }

        public static async Task<IJsonResponse> ToJsonResponseAsync(this DbUpdateConcurrencyException exception, CancellationToken cancellationToken = default)
        {
            var concurrencyConflict = await GetConcurrencyConflictAsync(exception, cancellationToken);

            var jsonResponse = HttpStatusCode.Conflict.ToFailureJsonResponse("Concurrency Conflict", "The data has been modified or row version didn't match.");

            jsonResponse.Extras["Conflicts"] = concurrencyConflict;

            return jsonResponse;
        }

        public static async Task<ConcurrencyConflict> GetConcurrencyConflictAsync(this DbUpdateConcurrencyException exception, CancellationToken cancellationToken)
        {
            var concurrencyConflict = new ConcurrencyConflict();

            foreach (var entry in exception.Entries)
            {
                var currentValues = await entry.GetDatabaseValuesAsync(cancellationToken);
                var proposedValues = entry.CurrentValues;

                var id = proposedValues["Id"]?.ToString();

                if (id == null)
                {
                    continue;
                }

                if (currentValues == null)
                {
                    concurrencyConflict[id] = new ConcurrencyConflictInfo { Deleted = true };
                    continue;
                }

                var updatedConflict = new Dictionary<string, ConcurrencyConflictValue>();

                foreach (var property in currentValues.Properties)
                {
                    if (!entry.Property(property.Name).IsModified)
                    {
                        continue;
                    }

                    var proposed = proposedValues[property.Name];
                    var current = currentValues[property.Name];

                    if (!Equals(proposed, current))
                    {
                        updatedConflict[property.Name] = new ConcurrencyConflictValue(current, proposed);
                    }
                }

                if (updatedConflict.Count != 0)
                {
                    concurrencyConflict[id] = new ConcurrencyConflictInfo { Properties = updatedConflict };
                }
            }

            return concurrencyConflict;
        }
    }
}